#!/usr/bin/perl -w
# $Id$
# Dieses Script (sophomorix-print) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de

# Ziel: Dieses Script erzeugt aus der Liste mit
# Hinzukommenden Schülern Latex-Code, der in PDF und
# DVI umgewandelt wird.

# Für Entwickler:
# Nach open-Befehlen Suchen, Kommentarzeichen bei *Zum Testen* entfernen, 
# Dafür Kommentarzeichen vor *In Wirklichkeit* setzen.
# Nun wird auf Dateien in /development zurückgegriffen atatt auf System-Dateien


# 1. Buchstabe vom Nachnamen groß

# Bibliotheken
use strict;
use Getopt::Long;
use Sophomorix::SophomorixConfig;
use Sophomorix::SophomorixBase;
Getopt::Long::Configure ("bundling");
use DBI;
use Net::LDAP;
use Sophomorix::SophomorixPgLdap qw(check_connections
                                    get_print_data
                                    fetchadmins_from_adminclass
                                    fetchdata_from_account
                                    fetchnetexamplix_from_account
                                    fetchstudents_from_adminclass
                                   );

my @arguments = @ARGV;


#my $schul_name="---";

my $entries_per_page=36;

# Auslesen der Schulinfo-Datei
my $info_klasse="";
my $info_abteilung="";
my $info_klassen_typ="";
my $info_mail="";

# Auslsen von lehrer.txt
my $info_lehrer_gruppe="";
my $info_lehrer_nachname="";
my $info_lehrer_vorname="";
my $info_lehrer_datum="";
my $info_lehrer_login="";
my $info_lehrer_erstpass="";
my $info_lehrer_kuerzel="";
my $info_lehrer_quota="";
my $info_lehrer_mail_sender="";
my $info_lehrer_mail_alias="";


# Hashes, die aus Lehrerinfo-Datei erzeugt werden
# Benannt nach dem Value, der gesucht wird

# Nicht mehr gebraucht
#my %nachname_edv_lehrer=();

# Auslesen von user_db
my $klasse_protokoll="";
my $name_protokoll="";
my $vorname_protokoll="";
my $nachname_protokoll="";
my $loginname_protokoll="";
my $passwort_protokoll="";
my $geburtsdatum_protokoll="";

# der aus user_db geholte identifier
my $identifier_protokoll="";

my $argument="";

my %schueler_im_system_hash=();
my $schueler_protokoll_zeile=0;

# Latex-Datei erstellen
my $rand_bemerkung_lehrer=1; # 1=schon gesetzt
my $anzahl_karten_pro_seite=0;
my $anzahl_karten_pro_zeile=0;
my $eintrag_typ=0; # 1=Einzelschüler, 2=Klasse, 0=Erstwert
my $eintrag_typ_alt=0; # 1=Einzelschüler, 2=Klasse, 0=Erstwert
my $klasse_head="";
my $edv_lehrer_foot="";
my $edv_lehrer_rand="";

my %klasse_schueleranzahl=();
my %klasse_edv_lehrer=();

# Sortier-Hash und Sortierung
my %sortier_hash=();
my $key="";
my $value="";
my %sortier_klassen_hash=();
my %sortier_einzelschueler_hash=();
my @drucken_klasse_reihenfolge=();
my @drucken_einzelschueler_reihenfolge=();
my @drucken_reihenfolge=();
my $eintrag="";
my $klasse_protokoll_alt="";

# Nur zur Ausgabe
my $k="";
my $v="";

my $dev_null="1>/dev/null 2>/dev/null";

if($Conf::log_level>=3){
   # Alle systembefehle nicht mehr nach /dev/null
   $dev_null="";
}

# ===========================================================================
# Ende der Variablendeklaration
# ===========================================================================




# ===========================================================================
# Programmbeginn
# ===========================================================================


$Conf::log_level=1;
my $help=0;
my $info=0;
my $show=0;
my $alle=0;
my $lehrer=0;
my $caller="";

my $netexamplix="";

my $command="latex";
my $gruppe="";
my $classlist="";
my $one_per_page=0;
my $skiplock=0;

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "show|s" => \$show,
           "all|a" => \$alle,
           "class|c=s" => \$gruppe,
           "classlist=s" => \$classlist,
           "help|h" => \$help,
           "teacher|t" => \$lehrer,
           "caller|postfix=s" => \$caller,
           "netexamplix=s" => \$netexamplix,
           "command=s" => \$command,
           "one-per-page" => \$one_per_page,
           "skiplock" => \$skiplock,
           "info|i" => \$info
          );


# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);
&check_connections(),
&log_script_start(@arguments);


# --info
if ($info==0){
    &titel("sophomorix-print is creating output ...");
}


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-print prints user account data of recently added users to 
  /var/lib/sophomorix/print-data

Options:
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -a  / --all
  -t / --teacher
  -c class / --class class
  -s  / --show
  --caller / --postfix  name
  --command pdflatex  (standard is latex)
  -i / --info         (print to standard out)

Options for netexamplix:
  --netexamplix name_of_exam --caller user --class class1,class2,...

Please see the sophomorix-print(8) man pages for full documentation
');
   print "\n";
   exit;
}



# ===========================================================================
# netexamplix
# ===========================================================================

if ($netexamplix ne ""){
    if ($gruppe eq ""){
        print "   ERROR: You must use option --class class1,class2,... \n";
        exit;
    }
    if ($caller eq ""){
        print "   ERROR: You must use option --caller teacher \n";
        exit;
    }

    # decide where to create the file
    my ($homedir,$type,$gecos)=&fetchdata_from_account($caller);
    if ($type ne "teacher"){
        print "ERROR: Caller must be a teacher\n";
        exit;
    }

    my $netex_dir  = $homedir."/netexamplix";
    my $dir  = $netex_dir."/".$netexamplix;
    my $file = $dir."/students.cfg";

    print "Creating the following files for $caller ($gecos, $type):\n";
    # print "   $netex_dir\n";
    # print "   $dir\n";
    print "  $file\n";

    my @classlist_to_fetch = split(/,/,$gruppe);

    my @students=();

    foreach my $class_to_fetch (@classlist_to_fetch){
        print "     * Fetching users of class $class_to_fetch\n";
        my @users = &fetchstudents_from_adminclass($class_to_fetch);
        @students = (@students,@users);

    }

    if (not -e $netex_dir){
	system("mkdir -p $netex_dir");
        system("chown ${caller}.${DevelConf::teacher} $netex_dir");
    }
    if (not -e $dir){
	system("mkdir -p $dir");
        system("chown ${caller}.${DevelConf::teacher} $dir");
    }

    if (not $file=~/^$DevelConf::homedir_teacher\//){
        print "ERROR: I'm not creating file $file\n",
              "       outside $DevelConf::homedir_teacher\n";
        exit;
    }

    open(STUDENTS, ">$file");
    foreach my $user (@students){
        my $line=&fetchnetexamplix_from_account($user);
        #printf "  %-12s %-62s\n",$user,$line;
	print STUDENTS "$line\n";
    }

    close(STUDENTS);
    system("chown ${caller}.${DevelConf::teacher} $file");

    # writing teachers login:Surname, Firstname
    my $file_teacher = $dir."/teachers.cfg";
    print "  $file_teacher\n";
    my @teachers = &fetchstudents_from_adminclass(${DevelConf::teacher});
    open(TEACHERS, ">$file_teacher");
    foreach my $teacher (@teachers){
        my $line = &fetchnetexamplix_from_account($teacher);
        my ($name)=split(/:/,$line);
        print TEACHERS "$teacher:$name\n";
    }
    close(TEACHERS);
    system("chown ${caller}.${DevelConf::teacher} $file");
    exit;
}

 


# ===========================================================================
# Output-Dateinamen ermitteln
# ===========================================================================

my $output_file_basename="";

my $klasse_filename_part="";
if ($alle==1){
   $klasse_filename_part="all";
} elsif ($lehrer==1){
   $klasse_filename_part=${DevelConf::teacher};
}elsif ($gruppe ne ""){
   $klasse_filename_part="$gruppe";
}elsif ($classlist ne ""){
   $klasse_filename_part="$classlist-classlist";
} else {
   $klasse_filename_part="add";
}


my $caller_filename_part="";
if ($caller ne ""){
   $caller_filename_part="-"."$caller";
}


$output_file_basename="$klasse_filename_part"."$caller_filename_part";

if($Conf::log_level>=3){
   print "Basisname der Druckdateien ist: $output_file_basename \n";
}


# ===========================================================================
# LATEX-Vorspann schreiben
# ===========================================================================

# *.tex-Datei öffnen
open(LATEX,
     ">${DevelConf::druck_pfad}/${output_file_basename}.tex") || die "Fehler: $!";

# *.csv-Datei öffnen (windows)
open(CSV,
        ">${DevelConf::druck_pfad}/${output_file_basename}.csv") || die "Fehler: $!";
# *.csv-Datei öffnen (linux)
open(UNIXCSV,
        ">${DevelConf::druck_pfad}/${output_file_basename}-unix.csv") || die "Fehler: $!";


print LATEX ('%% This preamble was created from sophomorix-print
\documentclass[11pt,fleqn,oneside]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{ngerman}
\usepackage{fancyheadings}
\usepackage{multicol}
\usepackage{graphicx}

\pagestyle{fancy}
%% Erst mal auf Einzelschüler stellen
\lhead{\bf \large \today}
');


print LATEX ('\rhead{\bf \large Seite \thepage}');

if ($gruppe ne "") {
   # Klassenangabe gemacht  
  print LATEX ('
      \chead{\LARGE \bf ',"$gruppe",'}
   ');
} elsif ($classlist ne "") {
   # Klassenangabe gemacht  
  print LATEX ('
      \chead{\LARGE \bf ',"$classlist",'}
   ');
} else {
  print LATEX ('
      \chead{\LARGE \bf Einzelschüler}
   ');
}

my $latex_schoolname=&latexize_string("$Conf::schul_name");

print LATEX ('\lfoot{',"$latex_schoolname",'}',"\n");
print LATEX ('\rfoot{'," ${output_file_basename}",'.pdf','}',"\n");

print LATEX ('
\setlength{\voffset}{0mm}
\setlength{\hoffset}{0mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\marginparsep}{1.5mm}
\setlength{\marginparwidth}{60mm}
\setlength{\marginparpush}{1mm}
\setlength{\parindent}{0cm} %% Einrückungen am Absatzanfang verhindern
\setlength{\paperwidth}{210mm} %% Papierbreite angeben
\setlength{\paperheight}{297mm} %%Papierhöhe angeben
%% linker Rand einstellen:
\setlength{\oddsidemargin}{-17.9mm}
\setlength{\headsep}{3mm}      
\setlength{\headheight}{8mm}
\setlength{\topskip}{0mm}      
\setlength{\topmargin}{-18mm}
\setlength{\footskip}{-1mm}

\setlength{\headwidth}{189mm}
%% Einstellungen fuer die Umrahmungen:
\setlength{\textwidth}{189mm}
\setlength{\textheight}{261.5mm}

\renewcommand{\headrulewidth}{0.25mm}
\renewcommand{\footrulewidth}{0.25mm}
\setlength{\fboxrule}{0.1mm}
\renewcommand{\baselinestretch}{1}

%% Datensatz in ein Kärtchen umwandeln
\newcommand{\daten}[5]{
\fbox{
\begin{minipage}[b][26mm][c]{41mm}
\begin{center}
#1 #2 \par #3 \par #4 \par #5
\end{center}
\end{minipage}
}}

\newcommand{\datenoneperpage}[5]{
\begin{center}
\fbox{
\begin{minipage}[b][54mm][c]{85mm}
\begin{center}
\Large #1 #2 \par #3 \par \vspace{2mm} #4 \par #5
\end{center}
\end{minipage}
}
\end{center}
}

%% Lehrereintrag am Seitenrand erzeugen
\newcommand{\edvlehrer}[1]{
\marginpar{%
  %\begin{minipage}[t]{30mm}
\rotatebox{90}{%
\begin{minipage}[t]{26mm}
\begin{center}
\small #1
\end{center}
\end{minipage}
}%
 % \end{minipage}
}%
}

\begin{document}

\addtocontents{toc}{\textbf{Klasse \dotfill Seite} \par}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Hier beginnen die erzeugten Einträge

');

# ===========================================================================
# LATEX-Vorspann geschrieben
# ===========================================================================






# ===========================================================================
# user_db in Hash einlesen
# KEY = identifier wie im ersten Teil von sophomorix.add
# VALUE = Zeile in user_db
# ===========================================================================

# @print_data containes the lines of the database
my @print_data = &get_print_data();

foreach (@print_data){
    my $feld1;
    my $feld2;
    my $feld3;
    my $feld4;
    my $feld5;
    chomp($_); # Newline abschneiden
    # Hier ist alles noch ohne Ersetzungen
    # Protokolldateien bearbeiten
   ($feld1,               # weg
    $feld2,               # weg
    $feld3,               # weg
    $passwort_protokoll,  # weiterverwenden Case-Sensitives Original-Passwort
    $feld5                # weg
   )=split(/;/);

#    # Falls Umsteiger aus Vorversion
#    # Alles in Kleinschreibung
#    tr/A-ZÄÖÜ/a-zäöü/;
#    # Umlaute ersetzen
#    s/ä/ae/g;
#    s/ö/oe/g;
#    s/ü/ue/g;
#    s/ß/ss/g;
#    s/-//g;
   ($klasse_protokoll, 
    $name_protokoll,
    $loginname_protokoll,
    $feld4,                    # nicht verwenden
    $geburtsdatum_protokoll
   )=split(/;/);

   $loginname_protokoll=&latexize_string($loginname_protokoll);

   # Name aufsplitten
   ($vorname_protokoll,$nachname_protokoll)=split(/ /,$name_protokoll);
   # Zusammenhängen zu identifier
   $identifier_protokoll=join("",
                             ($nachname_protokoll,
                              ";",
                              $vorname_protokoll,
                              ";",
                              $geburtsdatum_protokoll));
   # In einem Hash ablegen
   my $value="$klasse_protokoll".";"."$name_protokoll".";".
          "$loginname_protokoll".";"."$passwort_protokoll".";".
          "$geburtsdatum_protokoll";
   # key=identifier value=Zeile in user_db
   $schueler_im_system_hash{$identifier_protokoll}="$value";
  }

if($Conf::log_level>=3){
   # Nur zum debuggen
   print("\n\nUser im System:\n\n");
   while (($k,$v) = each %schueler_im_system_hash){
      printf "%-40s %3s\n","$k","$v";
    }
}



# ===========================================================================
# Schülerdaten aus sophomorix.add dem System in Hash einlesen
# ===========================================================================

if ($classlist eq "" and $gruppe eq "" && $alle==0 && $lehrer==0) {
  # ohne Argument -> sophomorix.add einlesen und nur die übernehmen
  if($Conf::log_level>=2){
      &titel("Reading sophomorix.add ...");
  }
  open (SCHUELERPDF,
       "<${DevelConf::ergebnis_pfad}/sophomorix.add") 
       || die "Fehler: ${DevelConf::ergebnis_pfad}/sophomorix.add    $!";
    while(<SCHUELERPDF>){
      chomp();
      # in sophomorix.add gibts Zusatzangaben nach ::
      my ($klasse,$identifier)=split(/::/); 
      # passende Zeile aus user_db holen
      if (exists($schueler_im_system_hash{$identifier})){
         print ("   Creating login card for $identifier \n"); 
         $schueler_protokoll_zeile=$schueler_im_system_hash{$identifier};
       } else {
         # keine Protokoll-Zeile gefunden, Schüler ist noch nicht im System
         print ("   NO login card ($identifier not in the system)\n"); 
         next;
       }

       if($Conf::log_level>=3){
          print("\nIdentifier:               --$identifier--\n");
          print("\nZeile in user_db          --$schueler_protokoll_zeile--\n");
        }

     ($klasse_protokoll, 
      $name_protokoll,
      $loginname_protokoll,
      $passwort_protokoll,
      $geburtsdatum_protokoll
     )=split(/;/,$schueler_protokoll_zeile);

      # Hash erzeugen: alle auszudruckenden Schüler
      # Key = identifier
      # Value = Klasse
      $sortier_hash{$_}="$klasse_protokoll";
    }
  close(SCHUELERPDF);

} elsif ($alle==1) {
   # Argument "alle" -> nichts ausfiltern
   if($Conf::log_level>=2){
      print("\nArgument ist:  all\n");
    }
   foreach (keys %schueler_im_system_hash){
     my $klasse="";
     ($klasse)=split(/;/,$schueler_im_system_hash{$_});
      # Key = identifier
      # Value = Klasse
      $sortier_hash{$_}="$klasse";
   }

} elsif ($lehrer==1) {
    $argument=${DevelConf::teacher};
    my $klasse="";
    if($Conf::log_level>=2){
       print("\nArgument ist:  $argument\n");
     }
    foreach (keys %schueler_im_system_hash){
     ($klasse)=split(/;/,$schueler_im_system_hash{$_});
      if ($argument eq $klasse){
         # Key = identifier
         # Value = Klasse
         $sortier_hash{$_}="$klasse";
       }
    }    

} elsif ($gruppe ne "") {
   # Argument muss "klasse" sein -> filtern
   my $argument;
   if ($gruppe eq ${DevelConf::teacher}){
        print "Mit der Option --klasse können keine Lehrer angezeigt werden!\n\n";
        exit;
      } else {
        $argument="$gruppe";
      }

   my $klasse="";
   if($Conf::log_level>=2){
      print("\nArgument ist:  $argument\n");
   }
   foreach (keys %schueler_im_system_hash){
     ($klasse)=split(/;/,$schueler_im_system_hash{$_});
      if ($argument eq $klasse){
         # Key = identifier
         # Value = Klasse
         $sortier_hash{$_}="$klasse";
      }
   }
} elsif ($classlist ne "") {
   # Argument muss "klasse" sein -> filtern
   my $argument;
   if ($classlist eq ${DevelConf::teacher}){
        print "Mit der Option --klasse können keine Lehrer angezeigt werden!\n\n";
        exit;
      } else {
        $argument="$classlist";
      }

   my $klasse="";
   if($Conf::log_level>=2){
      print("\nArgument ist:  $argument\n");
   }
   foreach (keys %schueler_im_system_hash){
     ($klasse)=split(/;/,$schueler_im_system_hash{$_});
      if ($argument eq $klasse){
         # Key = identifier
         # Value = Klasse
         $sortier_hash{$_}="$klasse";
      }
   }
 }


if($Conf::log_level>=3){
   # Nur zum ausgeben 
   print("Für diese Schüler werden Druckkärtchen erzeugt\n\n"); 
   while (($key,$value) = each %sortier_hash){
      printf "%-40s %3s\n","$key","-$value-";
   }
}

# ===========================================================================
# Im sortier-Hash stehen nun alle auszudruckenden Schüler
# ===========================================================================





# ===========================================================================
# Schülerdaten in Klassen (über 4 Schüler) und Einzelschüler (1-4) einteilen
# ===========================================================================
# Hash mit Klassenbezeichnung und Anzahl erzeugen aus allen Schülern
foreach (values %sortier_hash){
#print "$_\n\n"; # gibt den Wert zurück (hier die Klasse)
   if (exists($klasse_schueleranzahl{$_})){
               $klasse_schueleranzahl{$_}++; # 1 dazuzählen
            } else {
   	      $klasse_schueleranzahl{$_}=1;
	    }
}
# Hash wurde erzeugt mit Klassenbezeichnung -- Schüleranzahl



# ===========================================================================
# Aufteilen aller Schülerdatensätze sortier_hash in 2 Hashes
# sortier_klassen_hash  und  sortier_einzelschueler_hash
# ===========================================================================

while(($key, $value) = each(%sortier_hash)){
# $key ist identifier, $value ist klasse
  if ($klasse_schueleranzahl{$value} < 5) {
     if($Conf::log_level>=3){
         # Alle Klassen unter 4 Schüler ausdrucken
         print "1 bis 4 $value\n";
      }
     $sortier_einzelschueler_hash{$key}="$value";
  } else {
     $sortier_klassen_hash{$key}="$value";
  }
}


# ===========================================================================
# Klassen Schülerdaten sortieren
# ===========================================================================
# Sortier-Hash sortieren
@drucken_klasse_reihenfolge = sort { 
   # sortieren nach Wert (Klassenbezeichnung) alphabetisch
   $sortier_klassen_hash{$a} cmp $sortier_klassen_hash{$b}
   or
   # Innerhalb der Klassenbezeichnung alphabetisch
   $a cmp $b 
} keys %sortier_klassen_hash;
# Alle anzulegenden Schüler befinden sich nun im sortier_hash

if($Conf::log_level>=3){
   # Nur zum Testen ausdrucken
   print "\n\nsortier_klassen_hash: \n\n";
   while (($k,$v) = each %sortier_klassen_hash){
      printf "%-40s %3s\n","$k","$v";
    }
}


# ===========================================================================
# Einzelschüler Schülerdaten sortieren
# ===========================================================================
# Sortier-Hash sortieren
@drucken_einzelschueler_reihenfolge = sort { 
   # sortieren nach Wert (Klassenbezeichnung) alphabetisch
   $sortier_einzelschueler_hash{$a} cmp $sortier_einzelschueler_hash{$b}
   or
   # Innerhalb der Klassenbezeichnung alphabetisch
   $a cmp $b 
} keys %sortier_einzelschueler_hash;
# Alle anzulegenden Schüler befinden sich nun im sortier_hash


if($Conf::log_level>=3){
   # Nur zum Testen ausdrucken
   print "\n\nEinzelschüler_hash\n\n";
   while (($k,$v) = each %sortier_einzelschueler_hash){
      printf "%-40s %3s\n","$k","$v";
    }
}

# ===========================================================================
# Liste Einzelschüler an Liste Klasse anhängen
# ===========================================================================
# Folgendes geht nicht mit push
@drucken_reihenfolge = (@drucken_klasse_reihenfolge, 
                         @drucken_einzelschueler_reihenfolge);



############################################################
# CLASSLIST
############################################################
if ($classlist ne ""){
    &titel("Creating classlist of $classlist");
    my $count=0;

    print LATEX "\\begin{tabular}{|r|p{55mm}|p{116mm}|}\\hline \n";
    print LATEX "\\rule[-2mm]{0mm}{7mm}\\textbf{Nr}& \\textbf{Name, Vorname} & \\\\ \\hline\\hline
";



    foreach $eintrag (@drucken_reihenfolge) {
        $count++;
        $schueler_protokoll_zeile=$schueler_im_system_hash{$eintrag};
        ($klasse_protokoll, 
        $name_protokoll,
        $loginname_protokoll,
        $passwort_protokoll,
        $geburtsdatum_protokoll
        )=split(/;/,$schueler_protokoll_zeile);

        my ($firstname,$surname)=split(/\s/,$name_protokoll);
        my $name=$surname.", ".$firstname;

        # Ausgabe
        if($Conf::log_level>=2){
           print "Erstelle Klassenliste für  $loginname_protokoll  ",
                 "in   $klasse_protokoll \n";
        }

        print LATEX "\\rule[-2mm]{0mm}{6.7mm} $count & $name &  \\\\  \\hline \n";


    }

    print LATEX "\\end{tabular} \n";


}# End CLASSLIST



############################################################
# ONE ENTRY PER PAGE
############################################################
if ($one_per_page==1){
    &titel("Creating a login list (1 per page)");
    # fetch dnsdomainname and hostname
    my $hostname=`hostname -s`;
    chomp($hostname);
    my $dnsdomainname=`dnsdomainname`;
    chomp($dnsdomainname);
    my $server=$hostname.".".$dnsdomainname;

    # read the template into variable
    my $template=${DevelConf::latex_templates}."/login-info-".${Conf::lang}.".tex";
    my $template_content="\n\n";
    open(TEMPLATE,"<$template") || die "Fehler: $!";
    while(<TEMPLATE>){
        $template_content=$template_content.$_;
    }
    close (TEMPLATE);

    # common changes to the template
    my $admins="admin1, admin2, ...";

    foreach $eintrag (@drucken_reihenfolge) {
        $schueler_protokoll_zeile=$schueler_im_system_hash{$eintrag};
        ($klasse_protokoll, 
        $name_protokoll,
        $loginname_protokoll,
        $passwort_protokoll,
        $geburtsdatum_protokoll
        )=split(/;/,$schueler_protokoll_zeile);
        # Ausgabe
        if($Conf::log_level>=2){
           print "Erstelle Login-Karte für  $loginname_protokoll  ",
                 "in   $klasse_protokoll \n";
        }

        # replace some characters
        my $latex_passwort_protokoll=&latexize_string($passwort_protokoll);

        # write header/contents of page
        print LATEX '\chead{\LARGE \bf ',
                   "$name_protokoll ($klasse_protokoll)",'}';
        print LATEX ('\addtocontents{toc}{',
                       "$name_protokoll",
                       ' \dotfill \thepage  \par}',"\n");
        print LATEX "\n";

        # copy the template
        my $template_data=$template_content;

        # modify the template
        $template_data=~s/\@\@user\@\@/${name_protokoll}/g;
        $template_data=~s/\@\@admins\@\@/${admins}/g;

        print LATEX "$template_data \n\n";

        print LATEX ('\datenoneperpage');
        # 1 Name
        print LATEX ('{',"$name_protokoll",'}');
        # 2 Nicht genutzt
        print LATEX ('{}');
        # 3 Klasse
        print LATEX ('{',"Klasse: $klasse_protokoll",'}');
        # 4 Login
        print LATEX ('{',"Login: $loginname_protokoll",'}');


        # 5 Passwort
        print LATEX ('{',"Passwort: $latex_passwort_protokoll",'}',"\n");

        # windows
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX "Anmeldung an einem Windowsrechner:\n\n";
        print LATEX "\\begin{tabbing}\n";
        print LATEX " Benutzername:\\qquad \\= \\texttt{$loginname_protokoll} \\\\ \n";
        print LATEX " Kennwort:     \\> \\texttt{$latex_passwort_protokoll} \\\\ \n";
        print LATEX " Domäne:       \\> \\texttt{???} \\\\ \n";
        print LATEX "\\end{tabbing}\n\n";
        print LATEX "\\vspace{-6mm}\n\n";

        # linux 
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX "Anmeldung an einem Linuxrechner:\n";
        print LATEX "\\begin{tabbing}\n";
        print LATEX " Login:\\qquad\\qquad \\= \\texttt{$loginname_protokoll} \\\\ \n";
        print LATEX " Passwort: \\> \\texttt{$latex_passwort_protokoll} \\\\ \n";
        print LATEX "\\end{tabbing}\n";
        print LATEX "\\vspace{-6mm}\n\n";

        # schulkonsole
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX "Pädagogische Funktionen mit der Schulkonsole im Intranet:\n\n";
        print LATEX " URL: \\texttt{https://${server}/schulkonsole/}\n\n";

        # horde
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX "Webmail mit Horde: \n\n";
        print LATEX " URL: \\texttt{https://${server}/horde3}\n\n";

        # ogo
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX " Groupware mit OpenGroupware: \n\n";
        print LATEX " URL: \\texttt{https://${server}/OpenGroupware}\n\n";

        # moodle
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX " Lernplattform mit Moodle: \n\n";
        print LATEX " URL: \\texttt{https://${server}/moodle}\n\n";

        # phpmyadmin
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX " Datenbankzugriff mit phpmyadmin: \n\n";
        print LATEX " URL: \\texttt{https://${server}/phpmyadmin}\n\n";

        # websvn
        print LATEX "\\rule{\\linewidth}{0.25mm}  \n\n";
        print LATEX " Versionskontrolle mit svn per Webfrontend: \n\n";
        print LATEX " URL: \\texttt{https://${server}/websvn}\n\n";



        print LATEX "\\newpage \n\n";
   }
} # End 1 PER PAGE



############################################################
# 36 ENTRIES PER PAGE
############################################################
if ($one_per_page==0 and $classlist eq ""){
    &titel("Creating a login list (36 per page)");
    $klasse_protokoll_alt="";

    # Sortierten Hash ausgeben lassen
    foreach $eintrag (@drucken_reihenfolge) {
       my $identifier="";

       # dirty fix
       if ($eintrag=~m/::/){
           ($a,$identifier)=split(/::/, $eintrag);
       } else {
            $identifier=$eintrag;
       }
       $schueler_protokoll_zeile=$schueler_im_system_hash{$identifier};
       if($Conf::log_level>=3){
       print ("\nDieser User wird gedruckt: $eintrag\n");
       print("Identifier:               --$identifier--\n");
       print("Zeile in user_db          --$schueler_protokoll_zeile--\n\n");
    }
   
   ($klasse_protokoll, 
    $name_protokoll,
    $loginname_protokoll,
    $passwort_protokoll,
    $geburtsdatum_protokoll
   )=split(/;/,$schueler_protokoll_zeile);
   # Ausgabe
   if($Conf::log_level>=2){
      print "Erstelle Login-Karte für  $loginname_protokoll  ",
            "in   $klasse_protokoll \n";
   }

   # replace some characters
   my $latex_passwort_protokoll=&latexize_string($passwort_protokoll);

   # Vorheriger Eintrag speichern
   $eintrag_typ_alt=$eintrag_typ;

   # Handelt es sich beim Eintrag um eine Klasse(2) oder Einzelschüler(1)
   if ($klasse_schueleranzahl{$klasse_protokoll} < 5) {
     # Einzelschüler
       $eintrag_typ=1;
   } else {
     # Klasse
       $eintrag_typ=2;
   }
   ###################################################################
   # Wenn neue Klasse begonnen wird
   if ($klasse_protokoll_alt ne $klasse_protokoll){
     # Wenn Klasse
     if ($eintrag_typ==2){
       $rand_bemerkung_lehrer=1; # Randbemerkung nicht mehr notwendig    
       if ($klasse_protokoll_alt ne ""){
          # Nicht der allererste Eintrag
          # Auffüllen der Seite
          while ($anzahl_karten_pro_seite < $entries_per_page){
             print LATEX ('\daten{\rule[2mm]{30mm}{0.5mm}}{}{}{}{}');
             print LATEX ("\n");
             $anzahl_karten_pro_seite++;
          }
          # Neue Seite beginnen
          print LATEX ("\n",'\newpage',"\n\n");
          # Katenzähler/Seite auf 0
          $anzahl_karten_pro_seite=0;
       }
       # Klassenbezeichner anpassen
       $klasse_head=$klasse_protokoll;
       # Erstes k entfernen
       $klasse_head=~s/k//;
       # alles in Großbuchstaben
       $klasse_head=~tr/a-z/A-Z/;
       # Kopfzeileneintrag
       print LATEX ('\chead{\LARGE \bf ',"$klasse_head",'}');
       print LATEX "\n";
       # Verantwortlicher Lehrer ermitteln

       # $edv_lehrer_foot 
       my @lehrerliste = 
          &Sophomorix::SophomorixPgLdap::fetchadmins_from_adminclass($klasse_protokoll);
       $edv_lehrer_foot = join(", ",@lehrerliste);

       print LATEX ('\cfoot{\bf ',
                         "$edv_lehrer_foot",
                         '}');
       print LATEX "\n";
       # Eintrag in das Inhaltsverzeichnis
       print LATEX ('\addtocontents{toc}{',
                       "$klasse_head",
                       ' \dotfill \thepage  \par}',"\n");
       print LATEX "\n";
     #######################################################################
     } else {
        # Wenn Einzelschüler
        # Wenn Vorgänger zu Klasse gehörte, Seite füllen
        if($eintrag_typ_alt==0){
            $rand_bemerkung_lehrer=0;
        }
        if($eintrag_typ_alt==2){
           # Vorgänger gehörte zur einer Klasse (über 4 Schüler)
           $rand_bemerkung_lehrer=0; # Randbemerkung wurde nicht gemacht
           # Auffüllen der Seite
           while ($anzahl_karten_pro_seite < $entries_per_page){
              print LATEX ('\daten{\rule[1mm]{30mm}{0.5mm}}{}{}{}{}');
              print LATEX ("\n");
              $anzahl_karten_pro_seite++;
           }
           # Neue Seite beginnen
           print LATEX ("\n",'\newpage',"\n\n");
           # Kartenzähler/Seite auf 0
           $anzahl_karten_pro_seite=0;
           # Kartenzähler/Zeile auf 0
           $anzahl_karten_pro_zeile=0;
           # Kopfzeileneintrag
           print LATEX ('\chead{\LARGE \bf ',"Einzelschüler",'}');
           print LATEX "\n";
           print LATEX ('\cfoot{}');
           print LATEX "\n";
           # Eintrag in das Inhaltsverzeichnis
           print LATEX ('\addtocontents{toc}{\textbf{',
                            "Einzelschüler",
                            '} \dotfill \thepage  \par}');
           print LATEX "\n";
           # EDV-Lehrerangabe machen, Zähler auf 0 setzen
           $rand_bemerkung_lehrer=0; # Randbemerkung wurde nicht gemacht
	} elsif ($eintrag_typ_alt==1) {
           # Wenn Einzelschüler
           # Vorgänger war auch Einzelschüler
           
           # Auffüllen der Zeile
	  if ($anzahl_karten_pro_zeile == 4) {$rand_bemerkung_lehrer=0};
           while ($anzahl_karten_pro_zeile !=4) {
               print LATEX ('\daten{\rule[2mm]{30mm}{0.5mm}}{}{}{}{}');
               print LATEX ("\n");
               $anzahl_karten_pro_seite++;
               $anzahl_karten_pro_zeile++;
               $rand_bemerkung_lehrer=0; # Randbemerkung wurde nicht gemacht
           }
           if($anzahl_karten_pro_seite == $entries_per_page) {
               print LATEX ("\n\n",'\newpage',"\n\n");
               $anzahl_karten_pro_seite=0;
	   }
          $anzahl_karten_pro_zeile=0;
        }
     }
   }


   # alte Klassenbezeicnung für nächsten Vergleich speichern
   $klasse_protokoll_alt=$klasse_protokoll;


   # wenn Randbemerkung noch nicht angegeben wurde, jetzt tun
   # Switch zur Randbemerkung schalten 
   if ($rand_bemerkung_lehrer==0) {
      # Verantwortlicher Lehrer ermitteln
      # Nur zuweisen, wenn Eintrag im Hash sonst wirds undef ??


      # $edv_lehrer_rand
      my @lehrerliste = &Sophomorix::SophomorixPgLdap::fetchadmins_from_adminclass($klasse_protokoll);
      $edv_lehrer_rand = join(",",@lehrerliste);

      # Verantwortlichen Lehrer einsetzten
      print LATEX ("\n",
                        '\edvlehrer{',
                        "$edv_lehrer_rand",
                        '}',
                        "\n");
      $rand_bemerkung_lehrer=1; # Randbemerkung wurde gemacht
   } # Ende der Randbemerkung


   # Datensatz anhängen
   print LATEX ('\daten');
   # 1 Name
   print LATEX ('{',"$name_protokoll",'}');
   # 2 Nicht genutzt
   print LATEX ('{}');
   # 3 Klasse
   print LATEX ('{',"Klasse: $klasse_protokoll",'}');
   # 4 Login
   print LATEX ('{',"Login: $loginname_protokoll",'}');
   # 5 Passwort
   print LATEX ('{',"Passwort: $latex_passwort_protokoll",'}',"\n");
   # Eintag ferig, Zähler erhöhen
   $anzahl_karten_pro_seite++;
   $anzahl_karten_pro_zeile++;
   
   # Zeile in add.csv schreiben (unix)georg: linliste
   print UNIXCSV ("$name_protokoll",";","$klasse_protokoll",";",
                  "$loginname_protokoll",";","$passwort_protokoll",";","\n");
   # Zeile in add.csv schreiben (windows-versuch 1) georg: winliste
   print CSV ("$name_protokoll",";","$klasse_protokoll",";",
              "$loginname_protokoll",";","$passwort_protokoll",";","\l\r");
   # Zeile auf konsole ausgeben
   if ($info==1){
       printf "%-11s%-11s%-11s%-40s\n",
              $loginname_protokoll,
              $passwort_protokoll,
              $klasse_protokoll,
              $name_protokoll;
   }
} # Ende foreach
# Nun sind alle Schüler in der LATEX-Datei eingelesen




# Allerletzte Seite (vor Inhaltsverzeichnis noch auffüllen)
while ($anzahl_karten_pro_seite < $entries_per_page){
   print LATEX ('\daten{\rule[2mm]{30mm}{0.5mm}}{}{}{}{}');
   print LATEX ("\n");
   $anzahl_karten_pro_seite++;
}

# ===========================================================================
# Klassen LATEX-Nachspann schreiben
# ===========================================================================
# Letze Seite mit leeren Einträgen füllen
while ($anzahl_karten_pro_seite < $entries_per_page){
        print LATEX ('\daten{\rule[2mm]{30mm}{0.5mm}}{}{}{}{}');
        print LATEX ("\n");
        $anzahl_karten_pro_seite++;
}



} # End 36 PER PAGE
############################################################
















# ===========================================================================
# Dokument beenden und Inhaltsverzeichnis schreiben
if ($gruppe ne "") {
   # Klassenangabe gemacht  
   print LATEX ('
      \end{document}
   ');
} elsif ($classlist ne "") {
   # Klassenangabe gemacht  
   print LATEX ('
      \end{document}
   ');
} else {
   print LATEX ('

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Hier enden die erzeugten Einträge

\newpage

\setlength{\columnsep}{15mm}
\setlength{\columnseprule}{0.4mm}

% Wenn sie bis 225 Klassen im Inhaltsverzeichnis wollen 
% dann erhöhen Sie folgenden Wert auf 5 erhöhen
\begin{multicols}{4}

\rhead{\bf \LARGE I}
\lhead{}
\chead{\bf \LARGE Inhaltsverzeichnis}
\cfoot{}

\tableofcontents

\end{multicols}

\end{document}

');
}


# ===========================================================================
# Latex-Dokument schließen
close(LATEX);
# CSV-Dokument schließen
close(CSV);
close(UNIXCSV);

# ===========================================================================
# LATEXEN des Dokuments
# ===========================================================================


if ($info==1){
    exit;
}


# einfacher
if ($command eq "pdflatex"){
    &pdflatexen;
} elsif ($command eq "latex"){
    # hoehere Qualitaet
    &latexen;
} else {
    print "\nI do not know how to process the file ($command ?)\n\n";
}





# Datei öffnen und mit acrobat-reader anzeigen falls --show
if ($show==1) {
      print "\nacroread: Öffne ${DevelConf::druck_pfad}/$output_file_basename.pdf\n\n";
      system("acroread ${DevelConf::druck_pfad}/$output_file_basename.pdf");
}


&log_script_end(@arguments);


# ===========================================================================
# Subroutinen
# ===========================================================================

sub latexize_string {
    # make string usable by latex (convert)
    my ($string) = @_;

    #replace existing \   with   \textbackslash{}
    $string=~s/\\/\\textbackslash\{\}/g;

    # here a \ added again as escape characters:
    #replace  _   with   \_
    $string=~s/_/\\_/g;
    #replace  $   with   \$
    $string=~s/\$/\\\$/g;
    #replace  #   with   \#
    $string=~s/\#/\\\#/g;
    #replace  &   with   \&
    $string=~s/\&/\\\&/g;
    #replace  %   with   \%
    $string=~s/\%/\\\%/g;
    #replace  {   with   \{
    $string=~s/\{/\\\{/g;
    #replace  }   with   \}
    $string=~s/\}/\\\}/g;
    # [] seem to work
     return $string; 
}


sub pdflatexen {
    &titel("pdflatex is creating output ...");
   system("cd ${DevelConf::druck_pfad}; pdflatex $output_file_basename.tex $dev_null");

}

sub latexen {
   &titel("latex is creating output ...");
   # PS aus $output_file_basename.tex erzeugen
   system("cd ${DevelConf::druck_pfad}; latex $output_file_basename.tex $dev_null");
   # 2x, wegen Inhaltsverzeichnis
   system("cd ${DevelConf::druck_pfad}; latex $output_file_basename.tex $dev_null");
   &titel("dvips is creating output ...");
   system("cd ${DevelConf::druck_pfad}; dvips $output_file_basename.dvi $dev_null");
   &titel("ps2pdf is creating output ...");
   system("cd ${DevelConf::druck_pfad}; ps2pdf $output_file_basename.ps $dev_null");

   system("rm ${DevelConf::druck_pfad}/$output_file_basename.log $dev_null");
   system("rm ${DevelConf::druck_pfad}/$output_file_basename.toc $dev_null");
   system("rm ${DevelConf::druck_pfad}/$output_file_basename.aux $dev_null");

   # Dateien für user unlesbar machen
   system("chmod 400 ${DevelConf::druck_pfad}/$output_file_basename.* $dev_null");
   # Zugriff von admin von windows aus erlauben
   system("chown admin.admin ${DevelConf::druck_pfad}/$output_file_basename.* $dev_null");
}



